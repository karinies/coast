#lang racket/base

;; Copyright 2011 Michael M. Gorlick

;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;       http://www.apache.org/licenses/LICENSE-2.0
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.

(require
 (only-in racket/vector vector-copy vector-map vector-memq)
 (only-in "../../persistent/hash.rkt" hash/eq/null hash/cons hash/contains? hash/ref vectors/hash)
 (only-in
  "../persistent/record.rkt"
  record? record/keys record/raw/kind record/raw/hash error/field/unknown error/unrecord)

 (only-in
  "utility.rkt"
  bind/return!
  decompile?
  error/motile/internal/call
  k/RETURN)

 (only-in "baseline.rkt" motile/decompile))

(provide
 record/cons/generate
 record/generate
 record/ref/generate)

;; The classic (map f l) in continuation-passing style (map f L k) where:
;; f - function applied by map to each member of list l. f accepts two arguments: a value and a continuation
;; l - the subject list of the map
;; k - continuation of the map
;(define (map/k f l k)
;  (if (null? l)
;      (k null)
;
;      (f
;       (car l)
;       (lambda (v1) (map/k f (cdr l) (lambda (v2) (k (cons v1 v2))))))))

;; The vector equivalent of map/k above.
;; (vector/map/k f source k) applies f to source, a vector of values, generates a new vector of results r, and invokes (k r).
;; f - a function of two arguments (f v k_x) where u is a value and k_x a continuation.
;;     f computes a new value v from u and then calls (k_x u)
;; source - The subject vector, the vector equivalent of the list in map.
;; k - the continuation for the vector/map itself which is passed the vector of results generated by f
(define (vector/map/k f source k)
  (let ((n (vector-length source)))
    (vector/map/next/k f source (make-vector n #f) 0 n k)))

;; f takes two arguments, a value and a continuation.
(define (vector/map/next/k f source outcome i n k)
  (if (< i n)
      (f (vector-ref source i) ; Argument of f.
         (lambda (v)           ; Continuation of f.
           (vector-set! outcome i v)
           (vector/map/next/k f source outcome (add1 i) n k)))
      
      (k outcome))) ; Give the outcome to the continuation of vector/map/k.

;; name - type name of record prototype (as a symbol)
;; tags - vector of field names (symbols) of record in field order
;; expressions - vector of Motile closures for initial field values in field order
(define (descriptor/record name tags expressions)
  (vector-immutable 'record name (vector-length tags) tags (vector-map (lambda (e) (motile/decompile e)) expressions)))

;; name - type name of record prototype (as a symbol)
;; tags - vector of field names (symbols) of record in field order
;; expressions - vector of Motile closures for initial field values in field order
(define (record/generate name tags expressions)
  (let ((descriptor #f))
    (lambda (k e g)
      (cond
        ((procedure? k)
         (vector/map/k
          (lambda (expression k/other) (expression k/other e g))
          expressions
          (lambda (values) (k (record/build name tags values)))))

         ((decompile? k e g) (bind/return! descriptor (descriptor/record name tags expressions)))

        (else (error/motile/internal/call 'record/generate))))))

;; name - symbol denoting record type/class
;; tags - vector of field names (as symbols) of record
;; values - vector of field values for record instance
;; Returns a record r of the form #(<record> name tags values #f) where
;;   tags is a tuple containing the tags
;;   values is a tuple containing the values.
;; The last element is a slot for a record signature.
(define (record/build name tags values)
  (vector '<record> name (vectors/hash hash/eq/null tags values) #f))


;  (vector-immutable '<record> name (vector/tuple tags) (vector/tuple values) #f))
;  (let* ((n (vector-length tags))
;         (r (make-vector (+ 3 n))))
;    (vector-set!  r 0 '<record>)
;    (vector-set!  r 1 name)
;    (vector-set!  r 2 tags)
;    (vector-copy! r 3 values)
;    r))

(define (descriptor/record/cons record n tags expressions)
  (vector-immutable
   'record/cons
   (motile/decompile record)
   n tags (vector-map (lambda (e) (motile/decompile e)) expressions)))

(define (record/cons/generate record tags expressions)
  (let ((n (vector-length tags))) ; Always n > 0.
    (if (= n 1)
      (record/cons/1/generate record tags expressions)
      (record/cons/N/generate record n tags expressions))))
               
(define (record/check use r)
  (unless (record? r)
    (error/unrecord use r)))

(define-syntax-rule (key/1 keys)               (vector-ref keys 0))
(define-syntax-rule (expression/1 expressions) (vector-ref expressions 0))

(define (record/cons/1/generate record keys expressions)
  (let ((descriptor #f))
    (lambda (k e g)
      (cond
        ((procedure? k)
         (record
          (lambda (r) ; Continuation for the record evaluation.
            (record/check 'record/cons r)
            ((expression/1 expressions)
             (lambda (v) (k (record/cons/1/update r (key/1 keys) v))) ; Continuation for the expression evaluation.
             e g))
          e g))

        ((decompile? k e g) (bind/return! descriptor (descriptor/record/cons record 1 keys expressions)))

        (else (error/motile/internal/call 'record/cons/1/generate))))))

;(define (record/cons/2/generate record tags expressions)
;  (let ((descriptor #f))
;    (lambda (k e g)
;      (cond
;        ((procedure? k)
;         (record ; Evaluate the record.
;          (lambda (r) ; Continuation for the record evaluation.
;            (record/check 'record/cons r)
;
;            ((expression/1 expressions) ; Obtain value_1 affiliated with tag_1.
;             (lambda (v1) ; Continuation for value_1.
;               ((expression/2 expressions) ; Evaluate value_2 affiliated with tag_2.
;                (lambda (v2) (k (record/cons/2/update r (tag/1 tags) v1 (tag/2 tags) v2))) ; Final continuation.
;                e g))
;             e g))
;          e g))
;
;        ((decompile? k e g) (bind/return! descriptor (descriptor/record/cons record 2 tags expressions)))
;        
;        (else (error/motile/internal/call 'record/cons/2/generate))))))
            
(define (record/cons/N/generate record n tags expressions)
  (let ((descriptor #f))
    (lambda (k e g)
      (cond
        ((procedure? k)
         (record
          (lambda (r)
            (record/check 'record/cons r)
            
            (vector/map/k
             (lambda (expression k/other) (expression k/other e g))
             expressions
             (lambda (values) (k (record/cons/N/update r n tags values)))))

          e g))

        ((decompile? k e g) (bind/return! descriptor (descriptor/record/cons record n tags expressions)))

        (else (error/motile/internal/call 'record/cons/3/generate))))))

;; expressions - vector of Motile closures to evaluate
;; f - final function whose value will be handed to k
;;     f is a function of one argument which will be a vector of the values of the expressions in expression order
;; k - final continuation
;; e - lexical run-time environment stack
;; g - global binding environmet
;; This routine is the vector equivalent of 
(define (expressions/evaluate expressions f k e g)
  (vector/map/k
   (lambda (expression k/other) (k/other (expression k/RETURN e g)))
   expressions
   k))

;; i - index of expression of interest
;; values - vector of values of expressions after evaluation
(define (expressions/sequential/evaluate expressions values i n f k e g)
  (cond
    ((< i n)
     ; Compute the value of the ith expression.
     (let ((expression (vector-ref expressions i)))
       (expression
        (lambda (v) ; Continuation for ith expression.
          (vector-set! values i v) ; Save the ith vale.
          (expressions/sequential/evaluate expressions values (add1 i) n f k e g)) ; Compute the remaining values.
        e g)))
    ((= i n)
     (k (f values))))) ; Apply the final continuation to the outcome of f.

(define (record/cons/1/update record key value)
  (let ((h (record/raw/hash record)))
    (if (hash/contains? h key)
        (vector '<record> (record/raw/kind record) (hash/cons h key value) #f)
        (error/field/unknown 'record/cons record key))))

;; v - vector of field keys.
;; Returns first key in vector v that is not a key of h.
;; Returns #f if all keys in vector v are present in h.
(define (key/unknown h v)
  (let loop ((i 0) (n (vector-length v)))
    (cond
      ((= i n) #f)
      ((hash/contains? h (vector-ref v i))
       (loop (add1 i) n))
      (else (vector-ref v i)))))

(define (record/cons/N/update record n keys values)
  (let* ((h (record/raw/hash record))
         (unknown (key/unknown h keys))) ; An unknown key in h or #f iff all keys are known in h.
    (if unknown
        (error/field/unknown 'record/cons record unknown)
        (vector '<record> (record/raw/kind record) (vectors/hash h keys values) #f))))

(define (descriptor/record/ref record tag failure)
  (vector-immutable 'record/ref (motile/decompile record) tag (and (procedure? failure) (motile/decompile failure))))

(define UNKNOWN (gensym 'UNKNOWN.)) ; No Motile closure can ever produce this value.

(define (record/ref/generate record key failure)
  (let ((descriptor #f))
    (lambda (k e g)
      (cond
        ((procedure? k)
         (record
          (lambda (r)
            (record/check 'record/ref r)
            (let ((value (hash/ref (record/raw/hash r) key UNKNOWN)))
              (cond
                ((not (eq? value UNKNOWN)) (k value))
                ((procedure? failure) (failure k e g))
                (else (error/field/unknown 'record/ref r key)))))
          e g))

        ((decompile? k e g) (bind/return! descriptor (descriptor/record/ref record key failure)))

        (else (error/motile/internal/call 'record/ref/generate))))))
    