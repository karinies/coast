#lang racket/base

;; Copyright 2011 Michael M. Gorlick

;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;       http://www.apache.org/licenses/LICENSE-2.0
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.

(require
 (only-in racket/vector vector-copy vector-map vector-memq)
 (only-in "../persistent/tuple.rkt" tuple/index tuple/ref vector/tuple)
 (only-in
  "../persistent/record.rkt"
  record? record/tags record/raw/kind record/raw/tags record/raw/values error/field/unknown error/unrecord)

 (only-in
  "utility.rkt"
  bind/return!
  decompile?
  error/motile/internal/call
  k/RETURN)

 (only-in "baseline.rkt" motile/decompile))

(provide
 record/cons/generate
 record/generate
 record/ref/generate)

;; The classic (map f l) in continuation-passing style (map f L k) where:
;; f - function applied by map to each member of list l. f accepts two arguments: a value and a continuation
;; l - the subject list of the map
;; k - continuation of the map
;(define (map/k f l k)
;  (if (null? l)
;      (k null)
;
;      (f
;       (car l)
;       (lambda (v1) (map/k f (cdr l) (lambda (v2) (k (cons v1 v2))))))))

;; The vector equivalent of map/k above.
;; (vector/map/k f source k) applies f to source, a vector of values, generates a new vector of results r, and invokes (k r).
;; f - a function of two arguments (f v k_x) where u is a value and k_x a continuation.
;;     f computes a new value v from u and then calls (k_x u)
;; source - The subject vector, the vector equivalent of the list in map.
;; k - the continuation for the vector/map itself which is passed the vector of results generated by f
(define (vector/map/k f source k)
  (let ((n (vector-length source)))
    (vector/map/next/k f source (make-vector n #f) 0 n k)))

;; f takes two arguments, a value and a continuation.
(define (vector/map/next/k f source outcome i n k)
  (if (< i n)
      (f (vector-ref source i) ; Argument of f.
         (lambda (v)           ; Continuation of f.
           (vector-set! outcome i v)
           (vector/map/next/k f source outcome (add1 i) n k)))
      
      (k outcome))) ; Give the outcome to the continuation of vector/map/k.

;; name - type name of record prototype (as a symbol)
;; tags - vector of field names (symbols) of record in field order
;; expressions - vector of Motile closures for initial field values in field order
(define (descriptor/record name tags expressions)
  (vector-immutable 'record name (vector-length tags) tags (vector-map (lambda (e) (motile/decompile e)) expressions)))

;; name - type name of record prototype (as a symbol)
;; tags - vector of field names (symbols) of record in field order
;; expressions - vector of Motile closures for initial field values in field order
(define (record/generate name tags expressions)
  (let ((descriptor #f))
    (lambda (k e g)
      (cond
        ((procedure? k)
         (vector/map/k
          (lambda (expression k/other) (expression k/other e g))
          expressions
          (lambda (values) (k (record/build name tags values)))))

         ((decompile? k e g) (bind/return! descriptor (descriptor/record name tags expressions)))

        (else (error/motile/internal/call 'record/generate))))))

;; name - symbol denoting record type/class
;; tags - vector of field names (as symbols) of record
;; values - vector of field values for record instance
;; Returns a record r of the form #(<record> name tags values #f) where
;;   tags is a tuple containing the tags
;;   values is a tuple containing the values.
;; The last element is a slot for a record signature.
(define (record/build name tags values)
  (vector-immutable '<record> name (vector/tuple tags) (vector/tuple values) #f))
;  (let* ((n (vector-length tags))
;         (r (make-vector (+ 3 n))))
;    (vector-set!  r 0 '<record>)
;    (vector-set!  r 1 name)
;    (vector-set!  r 2 tags)
;    (vector-copy! r 3 values)
;    r))

(define (descriptor/record/cons record n tags expressions)
  (vector-immutable
   'record/cons
   (motile/decompile record)
   n tags (vector-map (lambda (e) (motile/decompile e)) expressions)))

(define (record/cons/generate record tags expressions)
  (let ((n (vector-length tags))) ; Always n > 0.
    (cond
      ((= n 1) (record/cons/1/generate record tags expressions))
      ((= n 2) (record/cons/2/generate record tags expressions))
      (else    (record/cons/N/generate record n tags expressions)))))
               
(define-syntax-rule (tag/1 tags) (vector-ref tags 0))
(define-syntax-rule (tag/2 tags) (vector-ref tags 1))

(define-syntax-rule (expression/1 expressions) (vector-ref expressions 0))
(define-syntax-rule (expression/2 expressions) (vector-ref expressions 1))

(define (record/check use r)
  (unless (record? r)
    (error/unrecord use r)))

(define (record/cons/1/generate record tags expressions)
  (let ((descriptor #f))
    (lambda (k e g)
      (cond
        ((procedure? k)
         (record
          (lambda (r) ; Continuation for the record evaluation.
            (record/check 'record/cons r)
            ((expression/1 expressions)
             (lambda (v) (k (record/cons/1/update r (tag/1 tags) v))) ; Continuation for the expression evaluation.
             e g))
          e g))

        ((decompile? k e g) (bind/return! descriptor (descriptor/record/cons record 1 tags expressions)))

        (else (error/motile/internal/call 'record/cons/1/generate))))))

(define (record/cons/2/generate record tags expressions)
  (let ((descriptor #f))
    (lambda (k e g)
      (cond
        ((procedure? k)
         (record ; Evaluate the record.
          (lambda (r) ; Continuation for the record evaluation.
            (record/check 'record/cons r)

            ((expression/1 expressions) ; Obtain value_1 affiliated with tag_1.
             (lambda (v1) ; Continuation for value_1.
               ((expression/2 expressions) ; Evaluate value_2 affiliated with tag_2.
                (lambda (v2) (k (record/cons/2/update r (tag/1 tags) v1 (tag/2 tags) v2))) ; Final continuation.
                e g))
             e g))
          e g))

        ((decompile? k e g) (bind/return! descriptor (descriptor/record/cons record 2 tags expressions)))
        
        (else (error/motile/internal/call 'record/cons/2/generate))))))
            
(define (record/cons/N/generate record n tags expressions)
  (let ((descriptor #f))
    (lambda (k e g)
      (cond
        ((procedure? k)
         (record
          (lambda (r)
            (record/check 'record/cons r)
            
            (vector/map/k
             (lambda (expression k/other) (expression k/other e g))
             expressions
             (lambda (values) (k (record/cons/N/update r n tags values)))))

          e g))

        ((decompile? k e g) (bind/return! descriptor (descriptor/record/cons record n tags expressions)))

        (else (error/motile/internal/call 'record/cons/3/generate))))))

;; expressions - vector of Motile closures to evaluate
;; f - final function whose value will be handed to k
;;     f is a function of one argument which will be a vector of the values of the expressions in expression order
;; k - final continuation
;; e - lexical run-time environment stack
;; g - global binding environmet
;; This routine is the vector equivalent of 
(define (expressions/evaluate expressions f k e g)
  (vector/map/k
   (lambda (expression k/other) (k/other (expression k/RETURN e g)))
   expressions
   k))

;; i - index of expression of interest
;; values - vector of values of expressions after evaluation
(define (expressions/sequential/evaluate expressions values i n f k e g)
  (cond
    ((< i n)
     ; Compute the value of the ith expression.
     (let ((expression (vector-ref expressions i)))
       (expression
        (lambda (v) ; Continuation for ith expression.
          (vector-set! values i v) ; Save the ith vale.
          (expressions/sequential/evaluate expressions values (add1 i) n f k e g)) ; Compute the remaining values.
        e g)))
    ((= i n)
     (k (f values))))) ; Apply the final continuation to the outcome of f.


(define-syntax-rule (tag/index r tag)      (tuple/index (record/tags r) (lambda (x) (eq? x tag))))
(define-syntax-rule (field/set! v i value) (vector-set! v (add1 i) value)) ; Remember that v is a tuple #(<tuple> x_1 ... x_n).
(define-syntax-rule (field/ref  r i)       (tuple/ref (record/raw/values r) i))

;; Create a values successor to record r.
(define (record/successor r)
  (vector '<record> (record/raw/kind r) (record/raw/tags r) (vector-copy (record/raw/values r)) #f))


;; Update the values portion of record r and return r (MODIFIED).
(define (record/update! r tag value)
  (let ((i (tag/index r tag)))
    (if i
        (begin
          (field/set! (record/raw/values r) i value)
          r)
        (error/field/unknown 'record/cons r tag))))

(define (record/cons/1/update r tag value)
  (record/update! (record/successor r) tag value)
    

  (record/update! (vector-copy r) tag value))

(define (record/cons/2/update r tag_1 value_1 tag_2 value_2)
  (record/update!
   (record/update! (record/successor r) tag_1 value_1)
   tag_2 value_2))

(define (record/cons/N/update record n tags values)
  (let loop ((r (record/successor record)) (i 0))
    (if (< i n)
       (loop
        (record/update! r (vector-ref tags i) (vector-ref values i))
        (add1 i))
       r)))

(define (descriptor/record/ref record tag failure)
  (vector-immutable 'record/ref (motile/decompile record) tag (and (procedure? failure) (motile/decompile failure))))

(define (record/ref/generate record tag failure)
  (let ((descriptor #f))
    (lambda (k e g)
      (cond
        ((procedure? k)
         (record
          (lambda (r)
            (record/check 'record/ref r)
            (let ((i (tag/index r tag)))
              (cond
                (i                    (k (field/ref r i)))
                ((procedure? failure) (failure k e g))
                (else (error/field/unknown 'record/ref r tag)))))
          e g))

        ((decompile? k e g) (bind/return! descriptor (descriptor/record/ref record tag failure)))

        (else (error/motile/internal/call 'record/ref/generate))))))
    