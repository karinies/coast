#lang racket/base

(require
 racket/contract/base
 "../../murmur.rkt"
 "../gate.rkt")

(provide
 gate:challenge?
 (contract-out
  [gate/challenge (-> gate:challenge?)]
  [gate:challenge/peek (-> gate:challenge? exact-positive-integer?)]))

;; The challenge gate generates a random, monotonically increasing, sequence of large numbers.
;; To pass the murmur payload must be (<challenge> . <body>) where <challenge> is the current
;; challenge number generated by the gate.
;; On passing a new, strictly increasing, challenge number is generated for the gate.
(struct gate:challenge gate ())
(define (gate/challenge)
  (let ([r (box
            (+ (inexact->exact 
                (truncate (/ (* (current-inexact-milliseconds) 1000) 4))) ; Use a 4 usec clock tick for initial value.
               (random 1000000)))]) ; Add an integer random seed.
    (gate:challenge
     'gate:challenge
     ; 
     (lambda (m) (and (murmur? m) (= (car (murmur/payload m)) (unbox r))))
     (lambda (_m) (set-box! r (+ (unbox r) (random 100000) 1)))
     (lambda () #f)
     (lambda () (vector-immutable 'gate:challenge (unbox r)))
     #f)))

(define (gate:challenge/peek g)
  (vector-ref (gate/snap g) 1))
