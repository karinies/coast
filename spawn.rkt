#lang racket/base

(require
 racket/contract/base
 "Island/accessor.rkt"
 "Island/base.rkt"
 "Island/keystore.rkt"
 "curl/curl.rkt"
 "curve.rkt"
 "islet.rkt"
 "persistent/environ.rkt"
 "promise.rkt"
 "transport/access.rkt"
 "transport/gate.rkt"
 "transport/gates/whitelist.rkt"
 "transport/transports/bankers.rkt"
)

(provide
 (contract-out
  [subspawn/new (-> kp/base64/c trust/c environ? (or/c thunk/c #f) islet?)]
  [spawn/exchange/duplet* (-> (listof symbol?)       (or/c environ? #f)         duplet?)]
  [spawn/control/duplet*  (-> (listof symbol?)       (or/c environ? #f)         duplet?)]
  [spawn/exchange/curl    (-> (listof symbol?) gate? (or/c environ? #f) place/c curl?)]
  
  
  ))

;; origin - kp/base64 id of requesting island
;; trust - trust level assigned to spawned islet
;; global - global binding environ of spawn's execution site
;; policy - thunk that returns overarching gate for all access:send points.
;;          #f if no policy asserted.
;; Policy is a generator rather than a fixed set of gates since that permits the overarching gate
;; to vary over time, for example, exponential decay for the lifespan of each successive
;; policy generated gate or stricter limits based on workload.
(define (subspawn/new origin trust global policy)
  (let ([x (subislet/new (keystore/petname/look (this/keystore) origin) trust global)])
    (and
     x
     (let* ([whitelist/origin (gate/whitelist/island origin)]
            [whitelist/islet  (gate/whitelist/islet x)]
            [exchange/gate (if policy (gate/and whitelist/origin (policy)) whitelist/origin)]
            [exchange/t (transport:bankers/new)] ; Define the default exchange plane.
            [exchange/send    (access:send/new    exchange/t 'exchange/access:send    exchange/gate EMBARGO/NO)]
            [exchange/receive (access:receive/new exchange/t 'exchange/access:receive whitelist/islet)]
            ; Define the default control plane.
            [control/gate (if policy (gate/and whitelist/origin (policy)) whitelist/origin)]
            [control/t (transport:bankers/new)]
            [control/send    (access:send/new    control/t 'control/access:send    control/gate EMBARGO/NO)]
            [control/receive (access:receive/new control/t 'control/access:receive whitelist/islet)])
       (set-box!
        (islet/environ x)
        (vector-to-environ
         (unbox (islet/environ x))
         (vector
          ; kp/base64 of requesting island 
          'origin origin
          ; Minimum required gates for all access:send points.
          'policy/access:send policy
          ; Exchange plane.
          'exchange/transport      exchange/t
          'exchange/access:send    exchange/send
          'exchange/access:receive exchange/receive
          ; Control plane.
          'control/transport      control/t
          'control/access:send    control/send
          'control/access:receive control/receive)))
       x))))

;; Called from within a spawn to generate an exchange plane duplet that is whitelisted
;; for the island that created the spawn.
;; The thunk executing within the spawn 
(define (spawn/exchange/duplet* path metadata)
  (let* ([e (unbox (islet/environ (this/islet)))]
         [a/send     (environ/get e 'exchange/access:send    #f)]
         [a/receive  (environ/get e 'exchange/access:receive #f)]
         [keys (this/curve)]
         [core
          (curl/core/new* keys path (access/id a/send) metadata)])
    (accessor/add (this/accessors) a/send)
    (duplet/new a/receive (curl/new* core keys))))


;; Called from within a spawn to generate a control plane duplet that is whitelisted
;; for the island that created the spawn.
(define (spawn/control/duplet* path metadata)
  (let* ([e (unbox (islet/environ (this/islet)))]
         [a/send     (environ/get e 'control/access:send    #f)]
         [a/receive  (environ/get e 'control/access:receive #f)]
         [keys (this/curve)]
         [core
          (curl/core/new* keys path (access/id a/send) metadata)])
    (accessor/add (this/accessors) a/send)
    (duplet/new a/receive (curl/new* core keys))))

;; Within a spawn all CURLs are defined relative to the exchange plane and its single access:receive point.
;; Consequently a duplet/wait, sync, or sync/timeout on the exchange plane duplet is that is required
;; to receive any murmur sent via a CURL generated by spawn/exchange/curl.
(define (spawn/exchange/curl path gate metadata place)
  (let* ([e (unbox (islet/environ (this/islet)))]
         [t      (environ/get e 'exchange/transport #f)]
         [policy (environ/get e 'policy/access:send #f)]
         [a/send (access:send/new t 'exchange/access:send (if policy (gate/and (policy) gate) gate) (place/intra? place))]
         [keys (this/curve)]
         [core
          (curl/core/new* keys path (if (place/inter? place) (access/id a/send) a/send) metadata)])
    (when (place/inter? place) (accessor/add (this/accessors) a/send))
    (curl/new* core keys)))