#lang racket/base

(require
 "z85.rkt"
 [only-in typed/racket/base assert]
 [only-in racket/string string-join]
 [only-in racket/format ~a]
 [only-in "bindings/libsodium/crypto.rkt" crypto/box/keys crypto/sign/keys crypto/sign crypto/sign/verify]
 "time.rkt"
 "bindings/libczmq/zconfig.rkt")

(provide
 island/certificates/new
 zconfig/bytes
 zconfig/curl/make
 zconfig/curl/ok?
 zconfig/sign
 zconfig/sign/verify?)


;; Generate a pair of CURVE public and secret certificates containing two pairs of keys:
;; a public/secret key pair for island identification and communications encryption
;; and a second signing key pair for island signing of CURLs.
;;
;; Note: zpl = ZeroMQ Property Language. See: http://rfc.zeromq.org/spec:4


;; Generate a public certificate and a secret certificate for an island.
;; Both certificates are backwards compatible with CZMQ zcert.c
;; 
(define (island/certificates/new)
  (let-values ([(box/kp box/ks)   (crypto/box/keys)]
               [(sign/kp sign/ks) (crypto/sign/keys)])
    (let ([zpl/public (zconfig/new "root" #f)]
          [zpl/secret (zconfig/new "root" #f)]
          [now (date-to-ISO8601 (date/now))])

      ;; Generate the public certificate containing only the public encryption and signing keys.
      (zconfig/comment/set zpl/public "   ZeroMQ CURVE Public Certificate")
      (zconfig/comment/set zpl/public "   Exchange securely, or use a secure mechanism to verify the contents")
      (zconfig/comment/set zpl/public "   of this file after exchange. Store public certificates in your home")
      (zconfig/comment/set zpl/public "   directory, in the .curve subdirectory.")
      (zconfig/put zpl/public "/metadata/created" now)
      (zconfig/put zpl/public "/curve/public-key"     (zmq/z85/encode box/kp))
      (zconfig/put zpl/public "curve/public-sign-key" (zmq/z85/encode sign/kp))
      
      ;; Generate the secret certificate.
      (zconfig/comment/set zpl/secret "   **** Generated by Motile/Island. Backwards compatible with CZMQ zcert.c ****")
      (zconfig/comment/set zpl/secret "   ZeroMQ CURVE **Secret** Certificate")
      (zconfig/comment/set zpl/secret "   DO NOT PROVIDE THIS FILE TO OTHER USERS nor change its permissions.")
      (zconfig/put zpl/secret "/metadata/created" now)
      (zconfig/put zpl/secret "/curve/public-key"     (zmq/z85/encode box/kp))
      (zconfig/put zpl/secret "curve/secret-key"      (zmq/z85/encode box/ks))
      (zconfig/put zpl/secret "curve/public-sign-key" (zmq/z85/encode sign/kp))
      (zconfig/put zpl/secret "curve/secret-sign-key" (zmq/z85/encode sign/ks))

      (values zpl/public zpl/secret))))

;; Convert a zconfig to its canonical text representation.
(define (zconfig/bytes x)
  (let ((b (open-output-bytes)))
    (zconfig/save x b)
    (let ((s (get-output-bytes b #t)))
      (close-output-port b)
      s)))

;; Sign zconfig x using CURVE secret signing key sign/ks.
;; kp/sign is the public key half corresponding to sign/ks.
;; Returns a modified x containing additional signing headers in its metadata section.
(define (zconfig/sign x kp/sign ks/sign)
  (zconfig/put x "/metadata/sign-algorithm"  "CURVE-ed25519")
  (zconfig/put x "/metadata/public-sign-key" (key/z85 kp/sign))
  (zconfig/put x "/metadata/signed-on"       (date-to-ISO8601 (date/now)))
  ; Delete the existing signature if any.
  (zconfig/put x "/metadata/signature" "")
  (let ([signed (crypto/sign (zconfig/bytes x) (key/bytes ks/sign))])
    ; CURVE signature is a 64-byte prefix to the canonical text representation.
    (zconfig/put x "/metadata/signature" (zmq/z85/encode (subbytes signed 0 64)))
    x))

;; CURVE signature is 64 bytes (z85 encoding is 80 bytes).
(define CURVE/SIGNATURE/Z85/LENGTH 80)
;; CURVE public key for verifying a signature is 32 bytes (z85 encoding is 40 bytes).
(define CURVE/KEY/VERIFY/Z85/LENGTH 40)
;; CURVE public encryption key (used as island id) is 32 bytes
;; (z85 encoding is 40 bytes).
(define CURVE/KEY/Z85/LENGTH 40)

;; Given zconfig x and a public signing key (in binary as bytes)
;; verify that x was signed using the affiliated secret signing key.
;; Returns the public signing key (as a z85 string) if the signature is correct
;; and #f if the signature is missing, ill-formed, or incorrect.
(define (zconfig/sign/verify? x)
  (cond
    [(zconfig/locate x "/metadata/signature")
     ; Extract the signature and the public sigining key, both of which are in z85 format.
     (let ([signature/z85 (zconfig/resolve x "/metadata/signature" #f)]
           [kp/sign/z85   (zconfig/resolve x "/metadata/public-sign-key" #f)])
       (cond
         [(and
           signature/z85 (= (string-length signature/z85) CURVE/SIGNATURE/Z85/LENGTH)
           kp/sign/z85   (= (string-length kp/sign/z85)   CURVE/KEY/VERIFY/Z85/LENGTH))
          ;; Erase the signature from the zconfig.
          (zconfig/put x "metadata/signature" "")
          ; Prepend the signature to the canonical text representation.
          (let* ([block (bytes-append (zmq/z85/decode signature/z85) (zconfig/bytes x))]
                 [verify? (and (crypto/sign/verify block (zmq/z85/decode kp/sign/z85)) #t)])
            ; Patch up the zconfig structure.
            (zconfig/put x "/metadata/signature" signature/z85)
            (and verify? kp/sign/z85))]
         ; Signature is either missing or ill-formed.
         [else #f]))]
    [else #f])) ; No signature to verify.

;; Given CURVE key k return it as z85 encoded string.
(define (key/z85 k)
  (if (bytes? k) (zmq/z85/encode k) k))
;; Given CURVE key k return it as a byte string.
(define (key/bytes k)
  (if (string? k) (zmq/z85/decode k) k))

;; Construct ZPL-based CURL.
;; kp - Public encryption key of island
;; comments - (c_1 ... c_n) where each c_i is a comment string
;; path - list of strings, symbols, or numbers used to identify a transmit access point
;; parameters - (k_1 v_1 ... k_n v_n) where each k_i v_i will be represented as k_i = v_i in
;;        the query portion of the CURL
;; Returns a zconfig that, after signing, can be used in CURL advertisments
;; in the ZyRE beacon greetings of an island.
(define (zconfig/curl/make kp path parameters . comments)
  (let* ([u (zconfig/new "root" #f)]
         [now (date-to-ISO8601 (date/now))])
    (for-each (lambda (comment) (zconfig/comment/set u comment)) comments)
    ; Metadata section.
    (zconfig/put u "/metadata/created" now)
    ; CURL section.
    (zconfig/put u "/CURL/island" (key/z85 kp))
    (zconfig/put u "/CURL/path" (string-join (map (lambda (x) (~a x)) path)))
    (zconfig/put u "CURL/bindings" "")
    ;; Add name = value query parameters.
    (let loop ([query (zconfig/locate u "/CURL/bindings")] [items parameters])
      (cond
        [(null? items) u]
        [else
         (let* ([name  (~a (car items))]
                [value (~a (cadr items))]
                [child (zconfig/new name query)])
           (zconfig/value/set child value)
           (loop query (cddr items)))]))))
    ; Now sign it.
    ;(zconfig/sign u kp/sign ks/sign)))

;; Sanity check for signed zconfig CURLs.
;; Returns #t if the is properly structured and signed otherwise returns #f.
;; Note: Without a certificate at hand it is impossible to determine if the
;; island denoted in the CURL is the island that owns the signing keys used
;; to generate the CURL signature.
(define (zconfig/curl/ok? u)
  (let ([metadata (zconfig/locate u "/metadata")]
        [CURL     (zconfig/locate u "/CURL")])
    (if (and metadata CURL)
        (let ([created        (ISO8601-to-date (zconfig/resolve metadata "created"   ""))]
              [signed-on      (ISO8601-to-date (zconfig/resolve metadata "signed-on" ""))]
              [sign-algorithm (zconfig/resolve metadata "sign-algorithm" "")]
              [island         (zconfig/resolve CURL "island" "")]
              [path           (zconfig/resolve CURL "path" #f)])
          (and
           created   ; Created timestamp present.
           signed-on ; Signed on timestamp present.
           (time<=? created signed-on) ; CURL was created before it was signed.
           (string=? sign-algorithm "CURVE-ed25519") ; Expected signing algorithm used.
           (= (string-length island) CURVE/KEY/Z85/LENGTH) ; Island public key is the right length.
           path ; A path is present.
           #t))
        
        #f)))

;; Sample use.
;; (define-values (public secret) (island/certificates/new))

;; Saves the public certificate as <base>/public/<name>
;; and the secret certificate as <base>/secret/<name>_secret.
(define (island/certificates/save public secret base name)
  (let ([port/public (open-output-file (format "~a/public/~a" base name) #:exists 'replace)]
        [port/secret (open-output-file (format "~a/secret/~a_secret" base name) #:exists 'replace)])
    (zconfig/save public port/public)
    (close-output-port port/public)
    (zconfig/save secret port/secret)
    (close-output-port port/secret)))

;; Generate and save a group of test certificates.
;; Handy for debugging and constructing examples.
(define NAMES
  '(alice bob carol dave eva
    frank gwen hank irene jack
    katy lex malvern nina olin
    pam quinn ruth sam tara
    uri vera))

#|
Given that the empty directories /tmp/certs/public and /tmp/certs/secret
both exist then the call
    (island/certificates/test "/tmp/certs" NAMES)
will generate a public and a secret certificate for alice, bob, ..., uri, and vera.
|#
(define (island/certificates/test base names)
  (for-each
   names
   (lambda (n)
     (let-values ([(public secret) (island/certificates/new)])
       (island/certificates/save public secret base n)))))
      
