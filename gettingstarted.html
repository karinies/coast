<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>COAST - Getting started</title>
<link href="http://fonts.googleapis.com/css?family=Raleway:700,300" rel="stylesheet"
        type="text/css">
<link rel="stylesheet" href="css/prism.css">
<link rel="stylesheet" href="css/style.css">
</head>
<body>
<div class="wrapper">
<header>
  <div class="container">
    <h2 class="lone-header">COmputationAl State Transfer (COAST)</h2>
  </div>
</header>
<section>
  <div class="container">
    <ul class="docs-nav">
      <li><a href="index.html" class="cc-active">Home</a></li>
      <li class="separator"></li>
      <li><strong>Creating islands</strong></li>
      <li><a href="#hello" class="cc-active">The "Hello World!" island</a></li>
      <li><a href="#hello_two" class="cc-active">"Hello World!" with two islands</a></li>
      <li><strong>Introducing CURLs</strong></li>
      <li><a href="#curls_simple" class="cc-active">Hello CURL!</a></li>
      <li><a href="#curls_realistic" class="cc-active">CURLs getting real</a></li>
      <li><a href="#curls_promises" class="cc-active">Specific duplets: Promises</a></li>
      <li><a href="#curls_gates" class="cc-active">Managing CURLs using Gates</a></li>
      <li><strong>The Motile language</strong></li>
      <li><a href="#motile_simple" class="cc-active">A simple Motile computation</a></li>
      <li><a href="#motile_display_service" class="cc-active">A client-tailored Display Server</a></li>
      <li><a href="#motile_parameters" class="cc-active">Passing parameters to Motile</a></li>
      <li><strong>Concepts</strong></li>
      <li><a href="#concepts_island" class="cc-active">Islands and Islets</a></li>
      <li><a href="#concepts_curls" class="cc-active">CURLs, Duplets and Promises</a></li>
      <li><a href="#concepts_gates" class="cc-active">Gates</a></li>
      <li><a href="#concepts_motile" class="cc-active">Motile</a></li>
    </ul>
    <div class="docs-content">
      <h2 id="hello">Creating islands</h2>

    (TODO: Add clarification about "COAST" and "Motile/Island")
    (TODO: Prepare readers for what they are about to read: Explain that we include some basic info and links about Racket for people who aren't familiar with it.)
    (TODO: Introduce Alice and Bob (didn't I do that already?))
    (TODO: Add code practices for Racket or Scheme)
    (TODO: Add link to https://github.com/mgiorgio/coast-examples)

      <h3 id="hello">The "Hello World!" island</h3>

      This example shows how to print a "Hello World!" message using the Island infrastructure. It instantiates an island called Alice, starts it up, and Alice prints the message. Notice that, in this example, we are not using CURLs or any Motile code, it is only a single island printing a message.

      <h4>1) Preparing Racket to work with Island</h4>

      <p>First thing that we need for working with COAST is to create a Racket file and to add the proper libraries. Create a file and name it <i>hello.rkt</i> and add the following code:</p>

       
<pre><code class="language-scheme">#lang racket/base

;; Basic require to work with Island
(require
  Island/include/base)</code></pre>

<p>That tells Racket that we will use the racket/base language and that we require Island/include/base, the basic component of the Island framework.</p>

<h4>2) Setting up certificates</h4>

<p>There is some boilerplate code that you will require to setup the certificates. For these examples, we will use the default islands (alice, bob, carol...) because they come with default certificates, but you can check out here how to create your own certificates. In the same <i>hello.rkt</i> file, add the following code:</p>

<pre><code class="language-scheme">;; Boilerplate to setup Alice's certificates. You will need them to create Alice island.
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))

;; Create Alice's CURVE cryptographic keys
(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))</code></pre>

<p>That will let Island know where your certificates are (make sure that the path is correct). It will use <i>alice_secret</i> file to create the CURVE cryptographic keys for Alice.</p>

<p>Now we're ready to start adding our code in Alice.</p>

<h4>3) Creating the first computation</h4>

<p>We need an initial computation to bootstrap Alice, that is, to tell Alice what to do first:</p>

<pre><code class="language-scheme">;; The bootstrap computation for Alice island to say "Hello World!"
(define (alice/boot)
  (display "Hello World!"))</code></pre>

<p>We are creating a computation that will only print <i>"Hello World!"</i> and will do nothing else.</p>

<h4>4) Instantiating Alice</h4>

<pre><code class="language-scheme">;; Instantiate Alice island
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))</code></pre>

<h4>5) Running the example</h4>

<p>Now, hit <i>"Run"</i> on DrRacket to execute your code, and then type on the DrRacket's console:</p>

<pre><code class="language-scheme">(island/start alice)</code></pre>

<p>Don't forget to press enter after each command in the DrRacket's console.</p>

<p>If everything went right, you will see "Wello World!" in the console.</p>

<p>Now, shutdown Alice by typing:</p>

<pre><code class="language-scheme">(island/destroy alice)</code></pre>

<p>That was it!</p>

<p>In this example, we have seen how to create a computation using the Island infrastructure. We setup Racket, loaded the certificates, and created an initial computation.</p>

<h4>Complete source code</h4>

<p>See the entire <i>hello.rkt</i> file in <a href="https://github.com/mgiorgio/coast-examples/blob/master/hello-world-singleisland.rkt">Github</a> or here:</p>

<div class="source-all">
  <pre class="line-numbers"><code class="language-scheme">#lang racket/base

;; Basic require to work with Island
(require
  Island/include/base)

;; Boilerplate to setup Alice's certificates. You will need them to create Alice island.
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))

;; Create Alice's CURVE cryptographic keys
(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))

;; The bootstrap computation for Alice island to say "Hello World!"
(define (alice/boot)
  (display "Hello World!"))

;; Instantiate Alice island
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))</code></pre>
</div>

<hr />

<h3 id="hello_two">"Hello World!" with two islands</h3>

<p>In this example we will create two islands that will print the same message but they will not communicate with each other. It is quite similar as the previous one but this time Alice, and the new island, Bob, will introduce themselves.</p>

<h4>1) Setting up Racket, library, and certificates</h4>

<p>We will not explain again this boilerplate code since we did it in the previous example, but don't forget to include it:</p>

<pre><code class="language-scheme">#lang racket/base

(require
  Island/include/base
)

(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))</code></pre>

<h4>2) Creating a computation for Alice and Bob</h4>

<p>Now, we define a function that will be used for both Alice and Bob:</p>

<pre><code class="language-scheme">(define (islet/hello)
  (display (format "Hi, I am ~a" (island/nickname (this/island)))))</code></pre>

<h4>3) Instantiating Alice and Bob</h4>

<p>The following code instantiates both islands:</p>

<pre><code class="language-scheme">(define alice (island/new 'alice ALICE/CURVE/SECRET islet/hello))
(define bob   (island/new 'bob   BOB/CURVE/SECRET   islet/hello))</code></pre>

<h4>4) Running the example</h4>

<p>Finally, from the console we type:</p>

<pre><code class="language-scheme">(island/start alice)
(island/start bob)</code></pre>

<p>Alice will say "Hi, I am Alice", and Bob will say "Hi, I am Bob". Notice the use of <code class="language-scheme">(this/island)</code> and <code class="language-scheme">(island/name)</code>. The former returns the island executing the computation. The latter returns the nickname of a given island.</p>

<h4>Complete source code</h4>

<p>See this example in <a href="https://github.com/mgiorgio/coast-examples/blob/master/hello-world-twoislands.rkt">Github</a> or here:</p>
<div class="source-all">
  <pre class="line-numbers"><code class="language-scheme">#lang racket/base

(require
  Island/include/base
)

(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))

(define (islet/hello)
  (display (format "Hi, I am ~a" (island/nickname (this/island)))))

(define alice (island/new 'alice ALICE/CURVE/SECRET islet/hello))
(define bob   (island/new 'bob   BOB/CURVE/SECRET   islet/hello))</code></pre></div>

<hr />

  <h2>Introducing CURLs</h2>

  <p>Islets use <a href="#">CURLs</a> to communicate with each other. Briefly, a CURL unambiguously identifies a service offered by an islet, and also provides addressability for such service. That is, when an islet exercises a CURL, the underlying platform will take care of delivering the message. If islet <i>x</i> wants to send a message to islet <i>y</i>, then <i>x</i> must hold a CURL issued by <i>y</i>.</p>

  <h3 id="curls_simple">Hello CURL!</h3>

  <p>This example shows how two islets sharing memory space can communicate with each other. It is a simplified example because the CURL that enables the communication between islets is stored by the CURL issuer in a global variable. Notice that in Real-world, islets need to communicate with others without sharing memory space. Also, using a global variable to pass a CURL is far from being a good practice, nevertheless it works for our example.

  <p>Alice creates two islets and executes them: a Display Server and a message sender. The Display Server listens for messages coming via a CURL and prints them. The Message Sender uses the Display Server's CURL to send a message.</p>

  <p>As usual, we must initialize Island and Racket:</p>

<pre><code class="language-scheme">#lang racket/base

;; Notice that we require some additional Island collections.
(require
  Island/include/base
  Island/baseline
  Island/transport/gate)

(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))</code></pre>

<p>We define a <a href="https://docs.racket-lang.org/guide/boxes.html">box</a> (i.e. a container to put a single value) where we will store the CURL that an islet will use to communicate with the other:</p>

<pre><code class="language-scheme">;; Create a box with a dummy value inside.
(define curl-box (box #f))</code></pre>

<p>Now, we create the function with which Alice is created: (alice/boot). Internally, it defines four functions that are later on invoked:</p>
<ol>
  <li><code class="language-scheme">(server/listen)</code>: Creates a new CURL and listens for messages coming via that CURL. It defines what the Display Server will do.</li>
  <li><code class="language-scheme">(spawn/server)</code>: Creates and executes the Display Server.</li>
  <li><code class="language-scheme">(sender/send)</code>: Sends a message via the Display Server's CURL</li>
  <li><code class="language-scheme">(spawn/sender)</code>: Creates and executes the message sender.</li>
</ol>

<pre><code class="language-scheme">;; Define the bootstrap computation for Alice
(define (alice/boot)

  ;; This is the function for the Display Service at Alice. It creates a duplet containing the CURL used to communicate.
  (define (server/listen)
    ;; Create a duplet (containing a CURL). A couple of points about this:
    ;; 1) '(echo alice) is the service path.
    ;; 2) GATE/ALWAYS means that there are no constraints to use this CURL.
    ;; 3) #f means that no metadata is attached to the CURL.
    ;; 4) 'INTRA means that the CURL can only be used within Alice (it is intra-Island).
    (let ([display/duplet (islet/curl/new '(echo alice) GATE/ALWAYS #f 'INTRA)])

      ;; Put the CURL into the box (duplet/resolver extracts a CURL from a duplet)
      (set-box! curl-box (duplet/resolver display/duplet))

      ;; Listen for messages coming through the CURL. It blocks on the duplet's CURL until a message arrives, then it blocks back.
      (let loop ([m (duplet/block display/duplet)])
        ;; Extract the actual message (i.e. the murmur's payload)
        (let ([message (murmur/payload m)])
          ;; Show the message.
          (display message))
        (loop (duplet/block display/duplet)))))

  ;; This is a function that uses the sender to send its message through the boxed CURL.
  (define (sender/send)
    (send (unbox curl-box) (format "Hi, I am ~a, and I also run in Alice!" (islet/nickname (this/islet)))))

  ;; This function creates and executes the sender.
  (define (spawn/sender)
    ;; (islet/new) creates a new islet in the current island:
    ;; 1) (this/island) returns the current island.
    ;; 2) 'message.sender is the nickname of the new islet.
    ;; 3) TRUST/MODERATE defines the level of trust granted to the new islet.
    ;; 4) BASELINE/SPAWN is the Execution Site global binding environment.
    ;; 5) environ/null is an islet-specific binding environment.
    (let ([x (islet/new (this/island) 'message.sender TRUST/MODERATE BASELINE/SPAWN environ/null)])
      ;; Launch the new islet with the sender/send function.
      (islet/jumpstart x sender/send)))

  ;; This function creates an executes the Display Server.
  (define (spawn/server)
    ;; Similar to the previous function but uses 'echo.server as the nickname.
    (let ([x (islet/new (this/island) 'echo.server TRUST/MODERATE BASELINE/SPAWN environ/null)])
      (islet/jumpstart x server/listen)))

  ;; Call the functions defined above.
  (spawn/server)
  (sleep 1.0)
  (spawn/sender))</code></pre>

<p>You may notice that there is a new concept here: <strong>duplet</strong>. In short, a duplet is an abstraction that wraps a CURL and the mechanism to receive messages through it. See the <a href="">duplet documentation</a> for a more detailed explanation. For now, it is enough to know that a duplet contains one CURL that can be obtained using the <code class="language-scheme">(duplet/resolver <i>your_duplet</i>)</code> function.</p>

<p>Lastly, we define Alice and we are ready to go:</p>

<pre><code class="language-scheme">(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))</code></pre>

<p>Typing <code class="language-scheme">(island/start alice)</code> in DrRacket's console should print:

<pre><code class="language-none">Hi, I am message.sender@alice, and I also run in Alice!</code></pre>

<p>See the entire source code for this example (or see it in <a href="https://github.com/mgiorgio/coast-examples/blob/master/display-sameisland.rkt">Github</a>):</p>

<div class="source-all">
  <pre class="line-numbers"><code class="language-scheme">#lang racket/base

(require
  Island/include/base
  Island/baseline
  Island/transport/gate)

(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))

;; Create a box with a dummy value inside.
(define curl-box (box #f))

;; Define the bootstrap computation for Alice
(define (alice/boot)

  ;; This is the function for the Display Service at Alice. It creates a duplet containing the CURL used to communicate.
  (define (server/listen)
    ;; Create a duplet (containing a CURL). A couple of points about this:
    ;; 1) '(echo alice) is the service path.
    ;; 2) GATE/ALWAYS means that there are no constraints to use this CURL.
    ;; 3) #f means that no metadata is attached to the CURL.
    ;; 4) 'INTRA means that the CURL can only be used within Alice (it is intra-Island).
    (let ([display/duplet (islet/curl/new '(echo alice) GATE/ALWAYS #f 'INTRA)])

      ;; Put the CURL into the box (duplet/resolver extracts a CURL from a duplet)
      (set-box! curl-box (duplet/resolver display/duplet))

      ;; Listen for messages coming through the CURL. It blocks on the duplet's CURL until a message arrives, then it blocks back.
      (let loop ([m (duplet/block display/duplet)])
        ;; Extract the actual message (i.e. the murmur's payload)
        (let ([message (murmur/payload m)])
          ;; Show the message.
          (display message))
        (loop (duplet/block display/duplet)))))

  ;; This is a function that uses the sender to send its message through the boxed CURL.
  (define (sender/send)
    (send (unbox curl-box) (format "Hi, I am ~a, and I also run in Alice!" (islet/nickname (this/islet)))))

  ;; This function creates and executes the sender.
  (define (spawn/sender)
    ;; (islet/new) creates a new islet in the current island:
    ;; 1) (this/island) returns the current island.
    ;; 2) 'message.sender is the nickname of the new islet.
    ;; 3) TRUST/MODERATE defines the level of trust granted to the new islet.
    ;; 4) BASELINE/SPAWN is the Execution Site global binding environment.
    ;; 5) environ/null is an islet-specific binding environment.
    (let ([x (islet/new (this/island) 'message.sender TRUST/MODERATE BASELINE/SPAWN environ/null)])
      ;; Launch the new islet with the sender/send function.
      (islet/jumpstart x sender/send)))

  ;; This function creates an executes the Display Server.
  (define (spawn/server)
    ;; Similar to the previous function but uses 'echo.server as the nickname.
    (let ([x (islet/new (this/island) 'echo.server TRUST/MODERATE BASELINE/SPAWN environ/null)])
      (islet/jumpstart x server/listen)))

  ;; Call the functions defined above.
  (spawn/server)
  (sleep 1.0)
  (spawn/sender))

(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))</code></pre></div>

<hr />

<h3 id="curls_realistic">CURLs getting real</h3>

<p>As the reader must have imagined, there was a reason in the previous example to use a box to store a CURL globally, and that reason was to bypass a security mechanism in COAST called <a href="">communication by introduction</a>. In COAST, we like to think that politeness is paramount, therefore a person must be introduced to someone if that person wants to communicate with him or her. In the COAST terminology, if an islet <i>y wants to communicate with an islet x</i>, then <i>y</i> must be introduced to <i>x</i>.</p>

<p>Now, suppose that Janet wants to send a message to Joe, then Joe (or someone) should provide a CURL issued by him to Janet. However, if Joe was not previously introduced to Janet, how can he give her his CURL? For the sake of clarity, we decided to solve this chicken-and-egg problem using a box. Joe does not provide its CURL to Janet directly but puts it on a box where Janet can pack it up.</p>

<p>It is out of the scope of COAST how an islet receives the CURL of a service with which it needs to communicate; in the same way that, for example, REST does not define how a URL is distributed. In this example, an islet in Alice wants to send a message to an islet in Bob. Alice somehow received a textual representation of the CURL issued by Bob (perhaps by e-mail or written in a piece of paper). Let's see how our Display Service would work in this context.</p>

<p>As usual, we first setup the certificates:</p>

<pre><code class="language-scheme">#lang racket/base

(require
  Island/include/base
  Island/baseline
  Island/transport/gate)

(define CERTIFICATE/PUBLIC "./certificates/public/")
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))</code></pre>

<p>Notice that we define a constant for the public certificates as well (<code class="language-scheme">CERTIFICATE/PUBLIC</code>), we will use it next because we require using a <a href="">Keystore</a> to store the public certificates of the other islands.</p>

<p>In addition to the usual stuff we do for certificates, we define a constant for Alice's public key, create a keystore, and download all of the predefined public certificates:</p>

<pre><code class="language-scheme">;; Alice's public key.
(define ALICE/KP/BASE64 #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc")

;; Create a Keystore to store the public certificates of other islands.
(define KEYSTORE (keystore/new))
;; Download all of the predefined public certificates.
(keystore/load KEYSTORE CERTIFICATE/PUBLIC)</code></pre>

<p>Now, we embed in the code a textual representation of Alice's CURL:</p>

<pre><code class="language-scheme">;; The textual representation of the CURL for Alice's display service.
(define/curl/inline ALICE/CURL/DISPLAY
&#35;&lt;&lt;!!
SIGNATURE = &#35;"Nxm6zGGiZDiao5vc8aYfdEeOIME104GEeOt4_K3ys2xDP673elLrwWa56SKAWp7gR2RI25QKZW0NvB2i23NJCg"
CURL
    id = 2eac24e1-f4fb-440d-a771-b3b60266a982
    origin = &#35;"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc"
    path = (echo)
    access/id = access:send:echo
    created = "2014-05-17T16:17:17Z"
    metadata = &#35;f

!!
)</code></pre>

<p>What we have just done is hard-coding a CURL in our code, analogously to when we hard-code a URL to connect to a service.</p>

<p>At this point, we need to define functions for Alice and Bob:</p>

<pre><code class="language-scheme">;; Bob's bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (bob/boot alice/curl)
  ; Wait until Bob sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  ; Send message.
  (send alice/curl "Hi, this is Bob!"))

;; Bootstrap function for Alice who offers a display service.
(define (alice/boot)
  ; Define a (service/display) function.
  (define (service/display)
    ; Create a duplet to receive messages via Alice's CURL.
    ; Notice the use of (islet/curl/known/new). We use this function because it is a known CURL, we are not creating a brand new CURL.
    ; '(echo) is the service path (it must be the same as the one in the textual representation)
    ; 'access:send:echo is the access id (it must be the same as the one in the textual representation)
    (let ([server/duplet (islet/curl/known/new '(echo) 'access:send:echo GATE/ALWAYS environ/null)])
      (let loop ([m (duplet/block server/duplet)])
        (let ([payload (murmur/payload m)])
          (display payload))
        (loop (duplet/block server/duplet)))))
          
  (service/display))</code></pre>

<p>Also, we must convert the CURL's textual representation to a CURL entity:</p>

<pre><code class="language-scheme">;; Create an in-memory CURL from the textual representation.
(define alice/curl/display (curl/zpl/safe-to-curl ALICE/CURL/DISPLAY KEYSTORE))</code></pre>

<p>We instantiate both Alice and Bob:</p>

<pre><code class="language-scheme">;; Instantiate Alice and Bob.
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))
(define bob (island/new 'bob BOB/CURVE/SECRET (lambda () (bob/boot alice/curl/display))))</code></pre>

<p>Finally, we set the keystore to Alice and Bob:</p>

<pre><code class="language-scheme">;; Set Alice' and Bob' keystore. Since both islands are in the same address space, they can share the keystore.
(island/keystore/set alice KEYSTORE)
(island/keystore/set bob   KEYSTORE)</code></pre>

<p>Everything is ready to run our example, so in DrRacket's console, type:</p>

<pre><code class="language-scheme">(island/start alice)
(island/start bob)</code></pre>

<p>You will then see in DrRacket's console:</p>

<pre><code class="language-none">Hi, this is Bob!</code></pre>

<p>If you see some red messages in the console, make sure that you set logging to a proper level:

<pre><code class="language-scheme">(island/log/level/set 'warning</code><code class="language-scheme">)</code></pre>

<p>See the entire source code in <a href="https://github.com/mgiorgio/coast-examples/blob/master/display-differentislands.rkt">Github</a> or here:</p>

<div class="source-all">
  <pre class="line-numbers"><code class="language-scheme">#lang racket/base

(require
  Island/include/base
  Island/baseline
  Island/transport/gate)

(define CERTIFICATE/PUBLIC "./certificates/public/")
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))

;; Alice's public key.
(define ALICE/KP/BASE64 #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc")

;; Create a Keystore to store the public certificates of other islands.
(define KEYSTORE (keystore/new))
;; Download all of the predefined public certificates.
(keystore/load KEYSTORE CERTIFICATE/PUBLIC)

;; The textual representation of the CURL for Alice's display service.
(define/curl/inline ALICE/CURL/DISPLAY
&#35;&lt;&lt;!!
SIGNATURE = &#35;"Nxm6zGGiZDiao5vc8aYfdEeOIME104GEeOt4_K3ys2xDP673elLrwWa56SKAWp7gR2RI25QKZW0NvB2i23NJCg"
CURL
    id = 2eac24e1-f4fb-440d-a771-b3b60266a982
    origin = &#35;"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc"
    path = (echo)
    access/id = access:send:echo
    created = "2014-05-17T16:17:17Z"
    metadata = &#35;f

!!
)

;; Bob's bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (bob/boot alice/curl)
  ; Wait until Bob sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  ; Send message.
  (send alice/curl "Hi, this is Bob!"))

;; Bootstrap function for Alice who offers a display service.
(define (alice/boot)
  ; Define a (service/display) function.
  (define (service/display)
    ; Create a duplet to receive messages via Alice's CURL.
    ; Notice the use of (islet/curl/known/new). We use this function because it is a known CURL, we are not creating a brand new CURL.
    ; '(echo) is the service path (it must be the same as the one in the textual representation)
    ; 'access:send:echo is the access id (it must be the same as the one in the textual representation)
    (let ([server/duplet (islet/curl/known/new '(echo) 'access:send:echo GATE/ALWAYS environ/null)])
      (let loop ([m (duplet/block server/duplet)])
        (let ([payload (murmur/payload m)])
          (display payload))
        (loop (duplet/block server/duplet)))))
          
  (service/display))

;; Create an in-memory CURL from the textual representation.
(define alice/curl/display (curl/zpl/safe-to-curl ALICE/CURL/DISPLAY KEYSTORE))

;; Instantiate Alice and Bob.
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))
(define bob (island/new 'bob BOB/CURVE/SECRET (lambda () (bob/boot alice/curl/display))))

;; Set Alice' and Bob' keystore. Since both islands are in the same address space, they can share the keystore.
(island/keystore/set alice KEYSTORE)
(island/keystore/set bob   KEYSTORE)

(island/log/level/set 'warning)</code></pre></div>

<hr />

<h3 id="curls_promises">Specific duplets: Promises</h3>

<p>We will expand the last example to introduce a particular case of duplets: promises. A <a href="">promise</a> is a duplet that can only be used once.</p>

<p>In order to show how promises work, we turn the previous Display Server into an Echo Server. For that, when the server receives a message, instead of printing it into the console, it will reply it back to the sender. In order to do so, a client must send a CURL that the Echo Server will use to send the response back.</p>

<p>The source code is very similar to the previous example but we need to introduce some modifications on the Alice's and Bob's functions. Here is the new code with comments:</p>

<pre><code class="language-scheme">;; Bob's bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (bob/boot alice/curl)
  ; Wait until Bob sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  
  ; Create a CURL that the Echo Server (Alice) will use to send the response.
  (let ([p (promise/new)])
    ; Send a pair with the message and the CURL to receive it back.
    (send alice/curl (cons (promise/resolver p) "Hi, this is Bob!"))
    ; Wait for the response.
    (let* ([m (promise/block p)]
           [message (murmur/payload m)])
      ; Show the response.
      (display message))))

;; Bootstrap function for Alice who offers a display service.
(define (alice/boot)
  ; Define a (service/display) function.
  (define (service/echo)
    ; Create a duplet to receive messages via Alice's CURL.
    ; Notice the use of (islet/curl/known/new). We use this function because it is a known CURL, we are not creating a brand new CURL.
    ; '(echo) is the service path (it must be the same as the one in the textual representation)
    ; 'access:send:echo is the access id (it must be the same as the one in the textual representation)
    (let ([server/duplet (islet/curl/known/new '(echo) 'access:send:echo GATE/ALWAYS environ/null)])
      ; Wait for messages.
      (let loop ([m (duplet/block server/duplet)])
        ; Get the murmur's payload.
        (let ([payload (murmur/payload m)])
          ; Verify that what the server received is well-formed.
          (when (and
                 ; It is a pair.
                 (pair? payload)
                 ; First element is a CURL.
                 (curl? (car payload))
                 ; Second element is a string.
                 (string? (cdr payload)))
            ; Send it back.
            (send (car payload) (cdr payload))))
        (loop (duplet/block server/duplet)))))
  
  (service/echo))</code></pre>

  <p>Notice that Bob creates a promise (<code class="language-scheme">promise/new</code>), sends the promise's CURL, and then waits (<code class="language-scheme">promise/block</code>) for a response from Alice. Likewise, Alice now expects a pair instead of a message. The pair contains the CURL that must be used to send the response as its first element, and the message to send back as the second element.</p>

  <p>Here is the entire source code for this example (or see it in <a href="https://github.com/mgiorgio/coast-examples/blob/master/echo-server-promises.rkt">Github</a>:</p>

  <div class="source-all">
  <pre class="line-numbers"><code class="language-scheme">#lang racket/base

(require
  Island/include/base
  Island/baseline
  Island/transport/gate)

(define CERTIFICATE/PUBLIC "./certificates/public/")
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))

;; Alice's public key.
(define ALICE/KP/BASE64 #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc")

;; Create a Keystore to store the public certificates of other islands.
(define KEYSTORE (keystore/new))
;; Download all of the predefined public certificates.
(keystore/load KEYSTORE CERTIFICATE/PUBLIC)

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))

;; The textual representation of the CURL for Alice's echo service.
(define/curl/inline ALICE/CURL/ECHO
&#35;&lt;&lt;!!
SIGNATURE = &#35;"Nxm6zGGiZDiao5vc8aYfdEeOIME104GEeOt4_K3ys2xDP673elLrwWa56SKAWp7gR2RI25QKZW0NvB2i23NJCg"
CURL
    id = 2eac24e1-f4fb-440d-a771-b3b60266a982
    origin = &#35;"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc"
    path = (echo)
    access/id = access:send:echo
    created = "2014-05-17T16:17:17Z"
    metadata = &#35;f

!!
)

;; Bob's bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (bob/boot alice/curl)
  ; Wait until Bob sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  
  ; Create a CURL that the Echo Server (Alice) will use to send the response.
  (let ([p (promise/new)])
    ; Send a pair with the message and the CURL to receive it back.
    (send alice/curl (cons (promise/resolver p) "Hi, this is Bob!"))
    ; Wait for the response.
    (let* ([m (promise/block p)]
           [message (murmur/payload m)])
      ; Show the response.
      (display message))))

;; Bootstrap function for Alice who offers an Echo Service.
(define (alice/boot)
  ; Define a (service/echo) function.
  (define (service/echo)
    ; Create a duplet to receive messages via Alice's CURL.
    ; Notice the use of (islet/curl/known/new). We use this function because it is a known CURL, we are not creating a brand new CURL.
    ; '(echo) is the service path (it must be the same as the one in the textual representation)
    ; 'access:send:echo is the access id (it must be the same as the one in the textual representation)
    (let ([server/duplet (islet/curl/known/new '(echo) 'access:send:echo GATE/ALWAYS environ/null)])
      ; Wait for messages.
      (let loop ([m (duplet/block server/duplet)])
        ; Get the murmur's payload.
        (let ([payload (murmur/payload m)])
          ; Verify that what the server received is well-formed.
          (when (and
                 ; It is a pair.
                 (pair? payload)
                 ; Left element is a CURL.
                 (curl? (car payload))
                 ; Right element is a string.
                 (string? (cdr payload)))
            ; Send it back.
            (send (car payload) (cdr payload))))
        (loop (duplet/block server/duplet)))))
  
  (service/echo))

;; Create an in-memory CURL from the textual representation.
(define alice/curl/echo (curl/zpl/safe-to-curl ALICE/CURL/ECHO KEYSTORE))

;; Instantiate Alice and Bob.
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))
(define bob (island/new 'bob BOB/CURVE/SECRET (lambda () (bob/boot alice/curl/echo))))

;; Set Alice's and Bob's keystore. Since both islands are in the same address space, they can share the keystore.
(island/keystore/set alice KEYSTORE)
(island/keystore/set bob   KEYSTORE)

(island/log/level/set 'warning)</code></pre></div>

<hr />

<h3 id="curls_gates">Managing CURLs using Gates</h3>

<p><A href="">Gates</A> let you constrain the conditions in which a CURL can be used. For example, an island can define who is authorized to exercise it, when, how many times, and also to impose limits at the Execution Site level such as the maximum allowed memory or CPU cycles to use by the visiting computation.</p>

<p>We will expand farther the previous example to include a third island, Carol, that attempts to use Alice's Echo Service but it will not be able to do it.</p>

<p>The base source code remains the same as in the <a href="#curls_promises">previous example</a> but we need to also account for Carol, the new island. For that, we add the necessary constants:</p>

<pre><code class="language-scheme">(define CAROL/SECRET/PATH (string-append CERTIFICATE/SECRET "carol_secret"))
(define CAROL/KP/BASE64 #"rqM_XCwrsziuhIEsG1d0yMA05mivoewXhUmzKUzhb0s")
(define CAROL/CURVE/SECRET (path-to-curve CAROL/SECRET/PATH))</code></pre>

<p>We also slightly change Bob's function to make it a generic client function, that will be use by both Bob and Carol:</p>

<pre><code class="language-scheme">;; Echo Service Client bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (client/boot alice/curl)
  ; Wait until the client sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  
  ; Create a CURL that the Echo Server (Alice) will use to send the response.
  (let ([p (promise/new)])
    ; Send a pair with the message and the CURL to receive it back.
    (send alice/curl (cons (promise/resolver p) (format "Hi, this is ~a!" (island/nickname (this/island)))))
    ; Wait for the response.
    (let* ([m (promise/block p)]
           [message (murmur/payload m)])
      ; Show the response.
      (display message))))</code></pre>

<p>In addition, we change how the CURL gets created in Alice's function from:</p>

<pre><code class="language-scheme">(let ([server/duplet (islet/curl/known/new '(echo) 'access:send:echo GATE/ALWAYS environ/null)])</code></pre>

 <p>to:</p>

 <pre><code class="language-scheme">; The (gate/whitelist/island) function creates a gate that only lets pass messages coming from a specific set of islands.
 (let ([server/duplet (islet/curl/known/new '(echo) 'access:send:echo (gate/whitelist/island BOB/KP/BASE64) environ/null)])</code></pre>

 <p>because we want to make the CURL available only for Bob, and to reject Carol's messages. For that, we use the <code class="language-scheme">(gate/whitelist/island)</code> function, and pass Bob's public key.</p>

 <p>Finally, we add the instantiation of Carol and set its keystore:</p>

<pre><code class="language-scheme">(define carol (island/new 'carol CAROL/CURVE/SECRET (lambda () (client/boot alice/curl/echo))))
(island/keystore/set carol   KEYSTORE)</code></pre>

<p>Now, everything is ready to be executed. After you do:</p>

<pre><code class="language-scheme">(island/start alice)
(island/start bob)
(island/start carol)</code></pre>

<p>You will only see <code class="language-none">Hi, this is bob!</code> coming from Bob, because messages from Carol are discarded at the CURL's gate.

<p>Recall that the new stuff for Carol must be added to the previous example. See the entire source code in <a href="https://github.com/mgiorgio/coast-examples/blob/master/echo-server-gates.rkt">Github</a> or here:</p>

<div class="source-all">
  <pre class="line-numbers"><code class="language-scheme">#lang racket/base

(require
  Island/include/base
  Island/baseline
  Island/transport/gate
  Island/transport/gates/whitelist)

(define CERTIFICATE/PUBLIC "./certificates/public/")
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))
(define CAROL/SECRET/PATH (string-append CERTIFICATE/SECRET "carol_secret"))

;; Alice's, Bob's and Carol's public keys.
(define ALICE/KP/BASE64 #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc")
(define BOB/KP/BASE64   #"49u_B0VEdFFS3WCPMMX5T5MFQ3SaSHjM8fM63I4L338")
(define CAROL/KP/BASE64 #"rqM_XCwrsziuhIEsG1d0yMA05mivoewXhUmzKUzhb0s")

;; Create a Keystore to store the public certificates of other islands.
(define KEYSTORE (keystore/new))
;; Download all of the predefined public certificates.
(keystore/load KEYSTORE CERTIFICATE/PUBLIC)

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))
(define CAROL/CURVE/SECRET (path-to-curve CAROL/SECRET/PATH))

;; The textual representation of the CURL for Alice's echo service.
(define/curl/inline ALICE/CURL/ECHO
&#35;&lt;&lt;!!
SIGNATURE = &#35;"Nxm6zGGiZDiao5vc8aYfdEeOIME104GEeOt4_K3ys2xDP673elLrwWa56SKAWp7gR2RI25QKZW0NvB2i23NJCg"
CURL
    id = 2eac24e1-f4fb-440d-a771-b3b60266a982
    origin = &#35;"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc"
    path = (echo)
    access/id = access:send:echo
    created = "2014-05-17T16:17:17Z"
    metadata = &#35;f

!!
)

;; Echo Service Client bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (client/boot alice/curl)
  ; Wait until the client sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  
  ; Create a CURL that the Echo Server (Alice) will use to send the response.
  (let ([p (promise/new)])
    ; Send a pair with the message and the CURL to receive it back.
    (send alice/curl (cons (promise/resolver p) (format "Hi, this is ~a!" (island/nickname (this/island)))))
    ; Wait for the response.
    (let* ([m (promise/block p)]
           [message (murmur/payload m)])
      ; Show the response.
      (display message))))

;; Bootstrap function for Alice who offers an Echo Service.
(define (alice/boot)
  ; Define a (service/echo) function.
  (define (service/echo)
    ; Create a duplet to receive messages via Alice's CURL.
    ; Notice the use of (islet/curl/known/new). We use this function because it is a known CURL, we are not creating a brand new CURL.
    ; '(echo) is the service path (it must be the same as the one in the textual representation)
    ; 'access:send:echo is the access id (it must be the same as the one in the textual representation)
    ; The (gate/whitelist/island) function creates a gate that only lets pass messages coming from a specific set of islands.
    (let ([server/duplet (islet/curl/known/new '(echo) 'access:send:echo (gate/whitelist/island BOB/KP/BASE64) environ/null)])
      ; Wait for messages.
      (let loop ([m (duplet/block server/duplet)])
        ; Get the murmur's payload.
        (let ([payload (murmur/payload m)])
          ; Verify that what the server received is well-formed.
          (when (and
                 ; It is a pair.
                 (pair? payload)
                 ; Left element is a CURL.
                 (curl? (car payload))
                 ; Right element is a string.
                 (string? (cdr payload)))
            ; Send it back.
            (send (car payload) (cdr payload))))
        (loop (duplet/block server/duplet)))))
  
  (service/echo))

;; Create an in-memory CURL from the textual representation.
(define alice/curl/echo (curl/zpl/safe-to-curl ALICE/CURL/ECHO KEYSTORE))

;; Instantiate Alice and Bob.
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))
(define bob (island/new 'bob BOB/CURVE/SECRET (lambda () (client/boot alice/curl/echo))))
(define carol (island/new 'carol CAROL/CURVE/SECRET (lambda () (client/boot alice/curl/echo))))

;; Set Alice' and Bob' keystore. Since both islands are in the same address space, they can share the keystore.
(island/keystore/set alice KEYSTORE)
(island/keystore/set bob   KEYSTORE)
(island/keystore/set carol   KEYSTORE)

(island/log/level/set 'warning)</code></pre></div>

<hr />

<h2>The Motile language</h2>

<p>Motile is a language for mobile computation integrated with the Island platform. Although Motile and Island are not the same thing, they are interrelated up to the point that we usually call them the <i>Motile/Island Platform</i>.</p>

<p>We use Motile to send computations to be remotely executed, either within the same island or on a different one. Motile is a single-assignment dialect of Scheme expressly created for defining COAST computations and the messages and CURLs they exchange.</p>

<h3 id="motile_simple">A simple Motile computation</h3>

<p>Before continuing with the Display Server and the Echo Server examples, we present a much simpler example using Motile. Here, an island sends a simple calculation to be solved by another island. Bob writes its computation using Motile and sends it to Alice, that will solve it and send the result back to Bob.</p>

<p>As always, we setup our islands:</p>

<pre><code class="language-scheme">#lang racket/base

(require
  Island/include/base
  Island/baseline
  Island/transport/gate
  Island/remote)

(define CERTIFICATE/PUBLIC "./certificates/public/")
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))

;; Alice's public key.
(define ALICE/KP/BASE64 #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc")

;; Create a Keystore to store the public certificates of other islands.
(define KEYSTORE (keystore/new))
;; Download all of the predefined public certificates.
(keystore/load KEYSTORE CERTIFICATE/PUBLIC)

;; The textual representation of the CURL for Alice's service.
(define/curl/inline ALICE/CURL/SPAWN
&#35;&lt;&lt;!!
SIGNATURE = #"GNzBZNi6r6WTBdASzv_R0GJjAiwaBYtHkZhiMlyKTD8E-S-mL-A7SMFR7_9IKNl8_JJcfzOIBQh4YDnP3JoWBw"
CURL
    id = 0dd4f4f5-72ce-40fe-996f-f80700c322f0
    origin = #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc"
    path = (service spawn)
    access/id = access:send.service.spawn
    created = "2014-05-30T14:47:58Z"
    metadata = #f

!!
)</code></pre>

<p>We now define the Motile computation, using the <code class="language-scheme">(island/compile)</code> function:</p>

<pre><code class="language-scheme">(define BOB/COMPUTATION
  (island/compile
   '(lambda () (+ 2 3))
   ))</code></pre>

<p>As you can see, the computation is pretty simple, it sums 2 and 3. Let's break this snippet down. We define a constant called <code class="language-scheme">BOB/COMPUTATION</code> with the output of the <code class="language-scheme">(island/compile)</code> function. This function receives Motile code and compiles it to Racket code that can be shipped for remote execution. The single quote (<code class="language-scheme">'</code>) means that everything after that will be a symbol. That is, <code class="language-scheme">'(lambda () (+ 2 3))</code> represents one symbol containing the <code class="language-scheme">(lambda () (+ 2 3))</code> expression. The <code class="language-scheme">(island/compile)</code> function will compile that expression into Racket code.</p>

<p>We create a function for Bob:</p>

<pre><code class="language-scheme">;; Bob's bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (bob/boot alice/curl)
  ; Wait until Bob sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  ; Send Bob's computation and wait for the response.
  (let* ([p (promise/new)]
         [response/curl (promise/resolver p)])
    (send alice/curl (cons response/curl BOB/COMPUTATION))
    (let* ([m (promise/block p)]
           [result (murmur/payload m)])
      ; Show result.
      (display result))))</code></pre>

<p>The function presented above creates a pair with a promise's CURL and <code class="language-scheme">BOB/COMPUTATION</code>, and sends it to Alice via <code class="language-scheme">alice/curl</code>. After that, it waits for a response.</p>

<p>We define a function for Alice:</p>

<pre><code class="language-scheme">;; Bootstrap function for Alice.
(define (alice/boot)
  ; Define a (service/execute) function.
  (define (service/execute)
    ; Create a duplet to receive messages via Alice's CURL.
    ; Notice the use of (islet/curl/known/new). We use this function because it is a known CURL, we are not creating a brand new CURL.
    ; '(remote chirp) is the service path (it must be the same as the one in the textual representation)
    ; 'access:send:chirp is the access id (it must be the same as the one in the textual representation)
    (let ([server/duplet (islet/curl/known/new '(service spawn) 'access:send.service.spawn GATE/ALWAYS environ/null)])
      (let loop ([m (duplet/block server/duplet)])
        ; Create a worker (i.e. an islet) to solve the incoming computation.
        ; 'client-worker is the worker's nickname.
        ; BASELINE is the binding environment for the new islet.
        (let ([worker (islet/new (this/island) 'client-worker TRUST/LOW BASELINE environ/null)]
              [payload (murmur/payload m)])
          ; Check that all parameters are correct.
          (when (and (pair? payload) (curl? (car payload)) (procedure? (cdr payload)))
            (let ([client/curl (car payload)]
                  [thunk (cdr payload)])
              ; Execute the computation and send the result back in no more than 10 seconds.
              (remote worker thunk client/curl 10.0))))
        (loop (duplet/block server/duplet)))))
  
  (service/execute))</code></pre>

  <p>With this function, Alice receives thunks (procedures with no parameters) and spawns workers to execute them. Notice that Alice expects to receive a pair with the thunk and a CURL to send the result back, for which it uses the <code class="language-scheme">(remote)</code> function.</p>

  <p>We finally setup the islands and we are good to go:</p>

<pre><code class="language-scheme">;; Create an in-memory CURL from the textual representation.
(define alice/curl/execute (curl/zpl/safe-to-curl ALICE/CURL/SPAWN KEYSTORE))

;; Instantiate Alice and Bob.
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))
(define bob (island/new 'bob BOB/CURVE/SECRET (lambda () (bob/boot alice/curl/execute))))

;; Set Alice' and Bob' keystore. Since both islands are in the same address space, they can share the keystore.
(island/keystore/set alice KEYSTORE)
(island/keystore/set bob   KEYSTORE)

(island/log/level/set 'warning)</code></pre>

<p>See the entire source code in <a href="https://github.com/mgiorgio/coast-examples/blob/master/motile-add.rkt">Github</a> or here:</p>

<div class="source-all">
  <pre class="line-numbers"><code class="language-scheme">#lang racket/base

(require
  Island/include/base
  Island/baseline
  Island/transport/gate
  Island/remote)

(define CERTIFICATE/PUBLIC "./certificates/public/")
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))

;; Alice's public key.
(define ALICE/KP/BASE64 #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc")

;; Create a Keystore to store the public certificates of other islands.
(define KEYSTORE (keystore/new))
;; Download all of the predefined public certificates.
(keystore/load KEYSTORE CERTIFICATE/PUBLIC)

;; The textual representation of the CURL for Alice's service.
(define/curl/inline ALICE/CURL/SPAWN
&#35;&lt;&lt;!!
SIGNATURE = #"GNzBZNi6r6WTBdASzv_R0GJjAiwaBYtHkZhiMlyKTD8E-S-mL-A7SMFR7_9IKNl8_JJcfzOIBQh4YDnP3JoWBw"
CURL
    id = 0dd4f4f5-72ce-40fe-996f-f80700c322f0
    origin = #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc"
    path = (service spawn)
    access/id = access:send.service.spawn
    created = "2014-05-30T14:47:58Z"
    metadata = #f

!!
)

(define BOB/COMPUTATION
  (island/compile
   '(lambda () (+ 2 3))
   ))

;; Bob's bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (bob/boot alice/curl)
  ; Wait until Bob sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  ; Send Bob's computation and wait for the response.
  (let* ([p (promise/new)]
         [response/curl (promise/resolver p)])
    (send alice/curl (cons response/curl BOB/COMPUTATION))
    (let* ([m (promise/block p)]
           [result (murmur/payload m)])
      ; Show result.
      (display result))))

;; Bootstrap function for Alice.
(define (alice/boot)
  ; Define a (service/execute) function.
  (define (service/execute)
    ; Create a duplet to receive messages via Alice's CURL.
    ; Notice the use of (islet/curl/known/new). We use this function because it is a known CURL, we are not creating a brand new CURL.
    ; '(remote chirp) is the service path (it must be the same as the one in the textual representation)
    ; 'access:send:chirp is the access id (it must be the same as the one in the textual representation)
    (let ([server/duplet (islet/curl/known/new '(service spawn) 'access:send.service.spawn GATE/ALWAYS environ/null)])
      (let loop ([m (duplet/block server/duplet)])
        ; Create a worker (i.e. an islet) to solve the incoming computation.
        ; 'client-worker is the worker's nickname.
        ; BASELINE is the binding environment for the new islet.
        (let ([worker (islet/new (this/island) 'client-worker TRUST/LOW BASELINE environ/null)]
              [payload (murmur/payload m)])
          ; Check that all parameters are correct.
          (when (and (pair? payload) (curl? (car payload)) (procedure? (cdr payload)))
            (let ([client/curl (car payload)]
                  [thunk (cdr payload)])
              ; Execute the computation and send the result back in no more than 10 seconds.
              (remote worker thunk client/curl 10.0))))
        (loop (duplet/block server/duplet)))))
  
  (service/execute))

;; Create an in-memory CURL from the textual representation.
(define alice/curl/execute (curl/zpl/safe-to-curl ALICE/CURL/SPAWN KEYSTORE))

;; Instantiate Alice and Bob.
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))
(define bob (island/new 'bob BOB/CURVE/SECRET (lambda () (bob/boot alice/curl/execute))))

;; Set Alice' and Bob' keystore. Since both islands are in the same address space, they can share the keystore.
(island/keystore/set alice KEYSTORE)
(island/keystore/set bob   KEYSTORE)

(island/log/level/set 'warning)</code></pre></div>

<h3 id="motile_display_service">A client-tailored Echo Server</h3>

<p>We modify the previous example so that, instead of having a client that sends a calculation and receives a result (server-driven), it is the client who decides what its computation running at the server side will do (client-driven). Specifically, in this example, the client will send a computation, and the server will do no more than only executing it. When executed on the server, the computation will send a message back to the client. This is different from the previous Echo Server examples because on those, the client sent only data, and the server knew what to do. In this example, the client decides what to do by implementing a computation that does that.</p>

<o>We setup environment and islands:</o>

<pre><code class="language-scheme">#lang racket/base

(require
  Island/include/base
  Island/baseline
  Island/transport/gate
  Island/remote)

(define CERTIFICATE/PUBLIC "./certificates/public/")
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))

;; Alice's public key.
(define ALICE/KP/BASE64 #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc")

;; Create a Keystore to store the public certificates of other islands.
(define KEYSTORE (keystore/new))
;; Download all of the predefined public certificates.
(keystore/load KEYSTORE CERTIFICATE/PUBLIC)

;; The textual representation of the CURL for Alice's service.
(define/curl/inline ALICE/CURL/SPAWN
&#35;&lt;&lt;!!
SIGNATURE = #"GNzBZNi6r6WTBdASzv_R0GJjAiwaBYtHkZhiMlyKTD8E-S-mL-A7SMFR7_9IKNl8_JJcfzOIBQh4YDnP3JoWBw"
CURL
    id = 0dd4f4f5-72ce-40fe-996f-f80700c322f0
    origin = #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc"
    path = (service spawn)
    access/id = access:send.service.spawn
    created = "2014-05-30T14:47:58Z"
    metadata = #f

!!
  )</code></pre>

  <p>We define the computation that the client (Bob) will send:</p>

  <pre><code class="language-scheme">(define BOB/COMPUTATION
  (island/compile
   '(lambda (curl/response)
      (lambda ()
        (send curl/response "Hello World!")))
   ))</code></pre>

<p>This computation is different from <code class="language-scheme">BOB/COMPUTATION</code> in the previous example because:</p>
<ol>
  <li>It has one parameter.</li>
  <li>It sends back something to the client instead of only producing a result.</li>
</ol>

<p>Let's answer a few questions about <code class="language-scheme">BOB/COMPUTATION</code>:</p>

<ul>
  <li><p><strong>Why are there two lambdas?</strong> This question is crucial to understand this example and it has to do with how functional programming works. Recall that we must send a thunk to be executed, that is, a procedure with no parameters. However, we do need one parameter in this computation, that is the CURL that will be used to send the result back. How do we deal with this situation? We define one function with the required parameters (i.e. the outer lambda) that returns another function with no parameters (i.e. the inner lambda). The outer lambda's parameters are in the lexical scope of the inner lambda, that is, those parameters are <strong>not</strong> free variables, they are bound variables. When the outer lambda gets evaluated, it will return the inner lambda, and nothing else will happen. In other words, evaluating the outer lambda does not cause the inner lambda to be evaluated; the inner lambda will be <i>eventually</i> evaluated. If you got this, you can continue to the next point, otherwise, take a look at this example:</p>
  <p>Suppose you have a function <i>f(x)</i> that returns <i>g(x)</i>. The <i>f(x)</i> function does not return the result of <i>g(x)</i>, it returns <i>g(x)</i> itself. When someone evaluates <i>f(x)</i>, the <i>g(x)</i> function will not be evaluated. For that to happen, someone will need to evaluate <i>f(x)</i> and then evaluate its result (i.e. <i>g(x)</i>). That is exactly what happens here with the two lambdas.</p></li>
  <li><strong>What is that</strong> <code class="language-scheme">(send)</code> <strong>function?</strong> That is a Motile function that lets computations send messages to other computations. It receives a CURL and what is to be sent. A computation will be able to invoke <code class="language-scheme">(send)</code> if this function is in the computation's binding environment.
</ul>

<p>We now define Bob's function:</p>

<pre><code class="language-scheme">;; Bob's bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (bob/boot alice/curl)
  ; Wait until Bob sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  ; Send Bob's computation and wait for the response.
  (let* ([p (promise/new)]
         [response/curl (promise/resolver p)]
         [thunk (motile/call BOB/COMPUTATION environ/null response/curl)])
    (send alice/curl thunk)
    (let* ([m (promise/block p)]
           [result (murmur/payload m)])
      ; Show result.
      (display result))))</code></pre>

<p>Here is where we solve the second part of passing an argument to the Motile computation. Recall that we are to send a procedure with no parameters (i.e. the inner lambda defined above), and it is returned when the outer lambda gets evaluated. If you look at the snippet above, you will see that the <code class="language-scheme">thunk</code> variable is defined as the result of the evaluation of <code class="language-scheme">(motile/call BOB/COMPUTATION environ/null response/curl)</code>. What we do here is precisely invoking the outer lambda, however we must do it by calling <code class="language-scheme">(motile/call)</code> because we are dealing with Motile code instead of Racket code. In short, executing <code class="language-scheme">BOB/COMPUTATION</code> will return the Motile inner lambda with the required arguments bound ready to be sent. Notice that we are passing the arguments we need when <code class="language-scheme">(motile/call)</code> is invoked.</p>

<p>The rest of the example does not differ much from the previous one. We define a function for Alice, which will spawn a new islet to execute the incoming thunk. Notice that Alice does not explicitely receive a CURL as in the previous example. Alice receives a computation that gets executed:</p>

<pre><code class="language-scheme">;; Bootstrap function for Alice.
(define (alice/boot)
  ; Define a (service/execute) function.
  (define (service/execute)
    ; Create a duplet to receive messages via Alice's CURL.
    ; Notice the use of (islet/curl/known/new). We use this function because it is a known CURL, we are not creating a brand new CURL.
    ; '(remote chirp) is the service path (it must be the same as the one in the textual representation)
    ; 'access:send:chirp is the access id (it must be the same as the one in the textual representation)
    (let ([server/duplet (islet/curl/known/new '(service spawn) 'access:send.service.spawn GATE/ALWAYS environ/null)])
      (let loop ([m (duplet/block server/duplet)])
        ; Create a worker (i.e. an islet) to solve the incoming computation.
        ; 'client-worker is the worker's nickname.
        ; BASELINE is the binding environment for the new islet.
        (let ([worker (islet/new (this/island) 'client-worker TRUST/LOW BASELINE/SPAWN environ/null)]
              [thunk (murmur/payload m)])
          ; Check that all parameters are correct.
          (when (procedure? thunk)
              ; Execute the computation and send the result back in no more than 10 seconds.
              (spawn worker thunk 10.0)))
        (loop (duplet/block server/duplet)))))
  
  (service/execute))</code></pre>

<p>Finally, we instantiate islands and all the rest:</p>

<pre><code class="language-scheme">;; Create an in-memory CURL from the textual representation.
(define alice/curl/execute (curl/zpl/safe-to-curl ALICE/CURL/SPAWN KEYSTORE))

;; Instantiate Alice and Bob.
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))
(define bob (island/new 'bob BOB/CURVE/SECRET (lambda () (bob/boot alice/curl/execute))))

;; Set Alice' and Bob' keystore. Since both islands are in the same address space, they can share the keystore.
(island/keystore/set alice KEYSTORE)
(island/keystore/set bob   KEYSTORE)

(island/log/level/set 'warning)</code></pre>

<p>You can see the entire example at <a href="https://github.com/mgiorgio/coast-examples/blob/master/motile-echo.rkt">Github</a> or here:</p>

<div class="source-all">
  <pre class="line-numbers"><code class="language-scheme">#lang racket/base

(require
  Island/include/base
  Island/baseline
  Island/transport/gate
  Island/remote)

(define CERTIFICATE/PUBLIC "./certificates/public/")
(define CERTIFICATE/SECRET "./certificates/secret/")
(define ALICE/SECRET/PATH (string-append CERTIFICATE/SECRET "alice_secret"))
(define BOB/SECRET/PATH   (string-append CERTIFICATE/SECRET "bob_secret"))

(define ALICE/CURVE/SECRET (path-to-curve ALICE/SECRET/PATH))
(define BOB/CURVE/SECRET   (path-to-curve BOB/SECRET/PATH))

;; Alice's public key.
(define ALICE/KP/BASE64 #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc")

;; Create a Keystore to store the public certificates of other islands.
(define KEYSTORE (keystore/new))
;; Download all of the predefined public certificates.
(keystore/load KEYSTORE CERTIFICATE/PUBLIC)

;; The textual representation of the CURL for Alice's service.
(define/curl/inline ALICE/CURL/SPAWN
  &#35;&lt;&lt;!!
SIGNATURE = #"GNzBZNi6r6WTBdASzv_R0GJjAiwaBYtHkZhiMlyKTD8E-S-mL-A7SMFR7_9IKNl8_JJcfzOIBQh4YDnP3JoWBw"
CURL
    id = 0dd4f4f5-72ce-40fe-996f-f80700c322f0
    origin = #"wdvbN1svfhEAewhM76oSVPKj-4kzfbDhaiTFW61VdUc"
    path = (service spawn)
    access/id = access:send.service.spawn
    created = "2014-05-30T14:47:58Z"
    metadata = #f

!!
  )

(define BOB/COMPUTATION
  (island/compile
   '(lambda (curl/response)
      (lambda ()
        (send curl/response "Hello World!")))
   ))

;; Bob's bootstrap function.
;; alice/curl is the CURL for Alice's service.
(define (bob/boot alice/curl)
  ; Wait until Bob sees Alice.
  (island/enter/wait ALICE/KP/BASE64)
  ; Send Bob's computation and wait for the response.
  (let* ([p (promise/new)]
         [response/curl (promise/resolver p)]
         [thunk (motile/call BOB/COMPUTATION environ/null response/curl)])
    (send alice/curl thunk)
    (let* ([m (promise/block p)]
           [result (murmur/payload m)])
      ; Show result.
      (display result))))

;; Bootstrap function for Alice.
(define (alice/boot)
  ; Define a (service/execute) function.
  (define (service/execute)
    ; Create a duplet to receive messages via Alice's CURL.
    ; Notice the use of (islet/curl/known/new). We use this function because it is a known CURL, we are not creating a brand new CURL.
    ; '(remote chirp) is the service path (it must be the same as the one in the textual representation)
    ; 'access:send:chirp is the access id (it must be the same as the one in the textual representation)
    (let ([server/duplet (islet/curl/known/new '(service spawn) 'access:send.service.spawn GATE/ALWAYS environ/null)])
      (let loop ([m (duplet/block server/duplet)])
        ; Create a worker (i.e. an islet) to solve the incoming computation.
        ; 'client-worker is the worker's nickname.
        ; BASELINE is the binding environment for the new islet.
        (let ([worker (islet/new (this/island) 'client-worker TRUST/LOW BASELINE/SPAWN environ/null)]
              [thunk (murmur/payload m)])
          ; Check that all parameters are correct.
          (when (procedure? thunk)
              ; Execute the computation and send the result back in no more than 10 seconds.
              (spawn worker thunk 10.0)))
        (loop (duplet/block server/duplet)))))
  
  (service/execute))

;; Create an in-memory CURL from the textual representation.
(define alice/curl/execute (curl/zpl/safe-to-curl ALICE/CURL/SPAWN KEYSTORE))

;; Instantiate Alice and Bob.
(define alice (island/new 'alice ALICE/CURVE/SECRET alice/boot))
(define bob (island/new 'bob BOB/CURVE/SECRET (lambda () (bob/boot alice/curl/execute))))

;; Set Alice' and Bob' keystore. Since both islands are in the same address space, they can share the keystore.
(island/keystore/set alice KEYSTORE)
(island/keystore/set bob   KEYSTORE)

(island/log/level/set 'warning)</code></pre></div>

</section>
<section class="vibrant centered">
  <div class="">
    This material is based upon work supported by the National Science Foundation under Grant Numbers CNS-1449159, CCF-0820222 and 
    CCF-0917129. Any opinions, findings, and conclusions or recommendations expressed in this material are those of 
    the author(s) and do not necessarily reflect the views of the National Science Foundation.
  </div>
</section>
</div>
<script src="js/jquery.min.js"></script> 
<script type="text/javascript" src="js/prism/prism.js"></script> 
<script src="js/layout.js"></script>
</body>
</html>
